package com.felixseifert.codinggeneral;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import static org.junit.jupiter.api.Assertions.assertEquals;

public class PossibilitiesToCombineTest {

    private static Stream<Arguments> getArgumentsStream() {
        // Key: length of the list which should be generated, value: expected return value
        Map<Long, Long> lengthAndResults = new HashMap<>();
        lengthAndResults.put(10L, 4L);
        lengthAndResults.put(11L, 5L);
        lengthAndResults.put(12L,6L);
        lengthAndResults.put(50L,110L);
        lengthAndResults.put(100L,450L);
        // Generate list from 0 to 10 with the taget value of 10
        return generateListStreamWithTarget(lengthAndResults, 0, 10, 10);
    }

    @DisplayName("Test possibilitiesToCombine with provided lists and target value")
    @ParameterizedTest(name = "Expected result: {2}")
    @MethodSource("getArgumentsStream")
    public void possibilitiesToCombineTest(List<Integer> list, int targetValue, long result) {
        assertEquals(result, PossibilitiesToCombine.possibilitiesToCombine(list, targetValue));
    }

    @DisplayName("Test possibilitiesToCombineImproved with provided lists and target value")
    @ParameterizedTest(name = "Expected result: {2}")
    @MethodSource("getArgumentsStream")
    public void possibilitiesToCombineImprovedTest(List<Integer> list, int targetValue, long result) {
        assertEquals(result, PossibilitiesToCombine.possibilitiesToCombineImproved(list, targetValue));
    }

    /**
     * Generates a stream lists with the same range, the same targetValue but a different length
     * @param lengthAndResults Map of the length of the lists generated by generateTestList() and the expected result
     * @param min Lower bound of each list
     * @param max Upper bound of each list
     * @param targetValue Target value which the summation of the numbers should reach
     * @return A stream of Arguments with similar lists and the same targetValue
     */
    private static Stream<Arguments> generateListStreamWithTarget(Map<Long, Long> lengthAndResults, int min, int max,
                                                                  int targetValue) {
        List<Arguments> listOfLists = new LinkedList<>();
        lengthAndResults.forEach((length, result) ->
                listOfLists.add(Arguments.of(generateTestList(length, min, max), targetValue, result)));
        return listOfLists.stream();
    }

    /**
     * Generates a list of integers repeating the number from min to max until the list has the requested length
     * @param length Length of the list
     * @param min Lower bound of the list
     * @param max Upper bound of the list
     * @return A list of integers
     */
    private static List<Integer> generateTestList(long length, int min, int max) {

        ListFromTo listGenerator = (start, stop) ->
                IntStream.rangeClosed(start, stop).boxed().collect(Collectors.toList());

        int range = max-min+1;

        List<Integer> list;
        if(range >= length) {
            list = listGenerator.generate(min, min + (int) length -1);
        }
        else {
            List<Integer> innerList = listGenerator.generate(min, max);
            list = new LinkedList<>();

            while(length >= range) {
                list.addAll(innerList);
                length -= range;
            }

            innerList = listGenerator.generate(min, min + (int) length -1);
            list.addAll(innerList);
        }
        return list;
    }

    private interface ListFromTo{
        List<Integer> generate(int start, int stop);
    }
}
